{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"FileIO": {
		"prefix": "fio",
		"body": [
			"#ifndef ONLINE_JUDGE",
			"freopen(\"in.txt\", \"r\", stdin);",
    		"freopen(\"out.txt\", \"w\", stdout);",
			"#endif"
		],
		"description": "File io from in.txt and out.txt"
	},
	"CP": {
		"prefix": "cp",
		"body": [
			"#include <bits/stdc++.h>",
			"#define ll long long",
			"#define ff first",
			"#define ss second",
			"#define pll pair<ll,ll>",
			"#define vll vector<ll>",
			"#define all(x) x.begin(),x.end()",
			"#define pb push_back",
			"#define YES cout<<\"YES\\n\"",
			"#define NO cout<<\"NO\\n\"",
			"#define dbg(x) cout<<\"x=\"<<x<<\"\\n\";",
			"#define MOD 1000000007",
			"#define out(x) cout<<x<<endl",
			"#define nl cout<<\"\\n\"",
			"#define show(x) cout<<x<<\" \"",
			"#include<ext/pb_ds/assoc_container.hpp>",
			"#include<ext/pb_ds/tree_policy.hpp>",
			"#define linecase() cout<<\"-----------------------\\n-----------------------\\n\";",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"ll pwr(ll a, ll b) {a %= MOD; ll res = 1; while (b > 0) {if (b & 1) res = res * a % MOD; a = a * a % MOD; b >>= 1;} return res;}",
			"template <typename T> using o_set = tree<T, null_type, greater_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"const ll INF = 0x3f3f3f3f3f3f3f3f;",
			"//Did you take input properly?",
			"//Did you copy the new input?",
			"//Does the question have testcases?",
			"",
			"void solve()",
			"{",
			"\t$1",
			"}",
			"",
			"int main()",
			"{",
			"\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);",
			"\t#ifndef ONLINE_JUDGE",
			"\tfreopen(\"in.txt\", \"r\", stdin);",
    		"\tfreopen(\"out.txt\", \"w\", stdout);",
			"\t#endif",
			"\tll t;",
			"\tcin >> t;",
			"\twhile(t--) solve();",
			"\treturn 0;",
			"}"
		],
	},
	"Binary Indexed Tree": {
		"prefix": "BIT",
		"body": [
		  "class BIT {",
		  "private:",
		  "    vector<ll> data;",
		  "    ",
		  "public:",
		  "    BIT(vector<ll> nums) {",
		  "        data.resize(nums.size() + 1);",
		  "        for (ll i = 1; i <= nums.size(); ++ i) {",
		  "            add(i, nums[i]);",
		  "        }",
		  "    }",
		  "    ",
		  "    BIT(ll n) {",
		  "        data.resize(n + 1);",
		  "    }",
		  "    ",
		  "    // add the value val to index i",
		  "    void add(ll i, ll val) {",
		  "        while (i <= data.size()) {",
		  "            data[i] += val;",
		  "            i += (i & (-i));",
		  "        }",
		  "    }",
		  "    ",
		  "    // get the prefix sum from 0 to i",
		  "    ll sum(ll i) {",
		  "        ll v = 0;",
		  "        while (i) {",
		  "            v += data[i];",
		  "            i -= (i & (-i));",
		  "        }",
		  "        return v;",
		  "    }",
		  " ",
		  "    // get the range sum between [i, j]",
		  "    ll queryRange(ll i, ll j) {",
		  "        ll s = sum(j);",
		  "        if(i>0) s -= sum(i-1);",
		  "        return s;",
		  "    }",
		  "};",
		  ""
		],
		"description": "Binary Indexed Tree"
	  },
	  "Inversion Count": {
		"prefix": "invcnt",
		"body": [
		  "ll a[800080], ans=0;",
		  "void Merge(ll ls, ll le, ll hb, ll he)",
		  "{",
		  "\tll k = 0, x = ls;",
		  "\tll temp[he - ls + 3];",
		  "\twhile (ls <= le && hb <= he)",
		  "\t{",
		  "\t\tif (a[ls] <= a[hb]) temp[k++] = a[ls++];",
		  "\t\telse ans +=(le-ls+1), temp[k++]=a[hb++];",
		  "\t}",
		  "\twhile (ls <= le) temp[k++] = a[ls++];",
		  "\twhile (hb <= he) temp[k++] = a[hb++];",
		  "\tfor (ll i = x; i <= he; i++) a[i] = temp[i-x];",
		  "\treturn;",
		  "}",
		  "",
		  "void MergeSort(ll lo, ll hi)",
		  "{",
		  "\tll mid = (lo + hi) >> 1;",
		  "\tif (lo < hi)",
		  "\t{",
		  "\t\tMergeSort(lo, mid);",
		  "\t\tMergeSort(mid + 1, hi);",
		  "\t\tMerge(lo, mid, mid + 1, hi);",
		  "\t}",
		  "}"
		],
		"description": "Inversion Count"
	  },
	  "Nested for loop": {
		"prefix": "for2",
		"body": [
		  "for (ll i = 0; i < ${1:n}; i++)",
		  "{",
		  "    for (ll j = 0; j < ${2:m}; j++)",
		  "    {",
		  "         ",
		  "    }",
		  "}",
		  ""
		],
		"description": "Nested for loop"
	  },
	  "for auto": {
		"prefix": "fora",
		"body": [
		  "for(auto ${1:x}:${2:y}) {",
		  "    $3",
		  "}"
		],
		"description": "for auto"
	  },
	  "for 1 to n": {
		"prefix": "for1",
		"body": [
		  "for(int ${1:i}=1;$1<${2:n};$1++) {",
		  "    $3",
		  "}"
		],
		"description": "for 1 to n"
	  },
	  "for 0 to n": {
		"prefix": "for0",
		"body": [
		  "for(int ${1:i}=0;$1<${2:n};$1++) {",
		  "    $3",
		  "}"
		],
		"description": "for 0 to n"
	  },
	  "Breadth First Search": {
		"prefix": "bfs",
		"body": [
		  "void bfs(ll s, vector<ll> adj[], bool vis[])",
		  "{",
		  "    ll i, j, node;",
		  "    queue <ll> q;",
		  "    q.push(s);",
		  "    vis[s] = 1;",
		  "",
		  "    while(!q.empty())",
		  "    {",
		  "        i = q.front();",
		  "        cout<<i<<\" \";",
		  "        q.pop();",
		  "        for(j = 0; j < adj[i].size(); j++)",
		  "        {",
		  "            node = adj[i][j];",
		  "            if(!vis[node])",
		  "            {",
		  "                q.push(node);",
		  "                vis[node] = 1;",
		  "            }",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "Breadth First Search"
	  },
	  "Compare struct": {
		"prefix": "cmp",
		"body": [
		  "bool cmp(${1:node} a, $1 b) {",
		  "    if(a.${2:x}!=b.$2) return a.$2 ${4:<} b.$2;",
		  "    return a.${3:y} $4 b.$3;",
		  "}"
		],
		"description": "Compare struct"
	  },
	  "Segment tree lazy": {
		"prefix": "segtree",
		"body": [
		  "ll a[200010];",
		  "ll tRe[800010],Lazy[800010];",
		  "void build(ll node,ll b,ll e){",
		  "    if(b==e){",
		  "        tRe[node]=a[b];",
		  "        return;",
		  "    }",
		  "    ll mid=(b+e)/2;",
		  "    ll left=2*node;",
		  "    ll right=2*node+1;",
		  "    build(left,b,mid);",
		  "    build(right,mid+1,e);",
		  "    tRe[node]=tRe[left]+tRe[right];",
		  "}",
		  "void Propagate(ll node,ll b,ll e){",
		  "    if(!Lazy[node]) return;",
		  "    ll left=2*node;",
		  "    ll right=2*node+1;",
		  "    tRe[node]+=1LL*(e-b+1)*Lazy[node];",
		  "    if(e>b){",
		  "        Lazy[left]+=Lazy[node];",
		  "        Lazy[right]+=Lazy[node];",
		  "    }",
		  "    Lazy[node]=0;",
		  "}",
		  "void update(ll node,ll b,ll e,ll l,ll r,ll val){",
		  "    Propagate(node,b,e);",
		  "    ll mid=(b+e)/2;",
		  "    ll left=2*node;",
		  "    ll right=2*node+1;",
		  "    if(e<l || b>r) return;",
		  "    if(b>=l && e<=r){",
		  "        tRe[node]+=1LL*(e-b+1)*val;",
		  "        if(e>b){",
		  "            Lazy[left]+=val;",
		  "            Lazy[right]+=val;",
		  "        }",
		  "        return;",
		  "    }",
		  "    update(left,b,mid,l,r,val);",
		  "    update(right,mid+1,e,l,r,val);",
		  "    tRe[node]=tRe[left]+tRe[right];",
		  "}",
		  "ll query(ll node,ll b,ll e,ll l,ll r){",
		  "    Propagate(node,b,e);",
		  "    if(e<l || b>r) return 0;",
		  "    if(b>=l && e<=r) return tRe[node];",
		  "    ll mid=(b+e)/2;",
		  "    ll left=2*node;",
		  "    ll right=2*node+1;",
		  "    ll q1=query(left,b,mid,l,r);",
		  "    ll q2=query(right,mid+1,e,l,r);",
		  "    return q1+q2;",
		  "}"
		],
		"description": "Segment tree lazy"
	  },
	  "Sieve of Eratosthenes": {
		"prefix": "seive",
		"body": [
		  "bool flag[NNN+1];",
		  "vector<ll>primes;",
		  "vector<ll> seive(ll NNN)",
		  "{",
		  "    ll i, j, total = 0, val;",
		  "    memset(flag,true,sizeof(flag));",
		  "    flag[0]=flag[1]=false;",
		  "    val = sqrt(NNN) + 1;",
		  "    for (i = 2; i < val; i++)",
		  "        if (flag[i])",
		  "            for (j = i; j * i <= NNN; j++)",
		  "                flag[i * j] = 0;",
		  "    for (i = 2; i <= NNN; i++)",
		  "        if (flag[i]){",
		  "            primes.push_back(i);",
		  "        };",
		  "    return primes;",
		  "}"
		],
		"description": "Sieve of Eratosthenes"
	  },
	  "Find divisors": {
		"prefix": "divisors",
		"body": [
		  "bool flag[200005];",
		  "ll primes[200005];",
		  "ll seive()",
		  "{",
		  "    ll total = 0, val;",
		  "    for (int i = 2; i <= 200000; i++)",
		  "        flag[i] = 1;",
		  "    val = sqrt(200000) + 1;",
		  "    for (int i = 2; i < val; i++)",
		  "        if (flag[i])",
		  "            for (int j = i; j * i <= 200000; j++)",
		  "                flag[i * j] = 0;",
		  "    for (int i = 2; i <= 200000; i++)",
		  "        if (flag[i])",
		  "            primes[total++] = i;",
		  "    return total;",
		  "}",
		  "ll store_primes[100000], freq_primes[100000], store_divisor[200000],Total_Prime, divisorCounter;",
		  "void divisor(ll N)",
		  "{",
		  "    ll val, count;",
		  "    val = sqrt(N) + 1;",
		  "    Total_Prime = 0;",
		  "    for (int i = 0; primes[i] < val; i++)",
		  "    {",
		  "        if (N % primes[i] == 0)",
		  "        {",
		  "            count = 0;",
		  "            while (N % primes[i] == 0)",
		  "            {",
		  "                N /= primes[i];",
		  "                count++;",
		  "            }",
		  "            store_primes[Total_Prime] = primes[i];",
		  "            freq_primes[Total_Prime] = count;",
		  "            Total_Prime++;",
		  "            val = sqrt(N) + 1; // sqrt again for fast compute.",
		  "        }",
		  "    }",
		  "    if (N > 1)",
		  "    {",
		  "        store_primes[Total_Prime] = N;",
		  "        freq_primes[Total_Prime] = 1;",
		  "        Total_Prime++;",
		  "    }",
		  "}",
		  "void Generate(ll cur, ll num)",
		  "{",
		  "    ll val;",
		  "    if (cur == Total_Prime)",
		  "    {",
		  "        store_divisor[divisorCounter++] = num;",
		  "    }",
		  "    else",
		  "    {",
		  "        val = 1;",
		  "        for (int i = 0; i <= freq_primes[cur]; i++)",
		  "        {",
		  "            Generate(cur + 1, num * val);",
		  "            val = val * store_primes[cur];",
		  "        }",
		  "    }",
		  "}",
		  "//call seive() on main",
		  "//call divisor(N) on solve",
		  "//call Generate(0,1) after divisor(N)",
		  "//number of divisors are stored in divisorCounter",
		  "//divisors are stored in store_divisor"
		],
		"description": "Find divisors"
	  },
	  "Left Rotate array": {
		"prefix": "leftRotate",
		"body": [
		  "void leftRotate(ll nums[], ll length, ll amount) { //{1,2,3,4,5},3,4",
		  "    amount%=length;//4%3=1",
		  "    reverse(nums,nums+amount);//{1,2,3}={3,2,1}",
		  "    reverse(nums+amount,nums+length);//{4,5}={5,4}",
		  "    reverse(nums,nums+length);//{3,2,1,5,4}={4,5,1,2,3}",
		  "}"
		],
		"description": "Left Rotate array"
	  },
	  "Coin change min unbounded": {
		"prefix": "coinChangeMin",
		"body": [
		  "ll dp[5000][50000];",
		  "void cc() {",
		  "    for(ll i=0; i<50000; i++){",
		  "        dp[0][i]=INF;",
		  "        if(i<primes.size()) dp[i][0]=0;",
		  "    } ",
		  "    for(ll i=1; i<=primes.size(); i++){",
		  "        for(ll j=1; j<50000; j++){",
		  "            if(j-primes[i-1]<=0) dp[i][j] = min(dp[i-1][j], 1+dp[i][j-primes[i-1]]);",
		  "            else dp[i][j] = dp[i-1][j];",
		  "            dp[i][j]=min(INF, dp[i][j]);",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "Coin change min unbounded"
	  },
	  "Coin change min 1 bounded": {
		"prefix": "coinChangeMin1bounded",
		"body": [
		  "ll dp[5000][50000];",
		  "void cc() {",
		  "    for(ll i=0; i<50000; i++){",
		  "        dp[0][i]=INF;",
		  "        if(i<coins.size()) dp[i][0]=0;",
		  "    } ",
		  "    for(ll i=1; i<=coins.size(); i++){",
		  "        for(ll j=1; j<50000; j++){",
		  "            if(j-coins[i-1]>=0) dp[i][j]=min(1+dp[i-1][j-coins[i-1]], dp[i-1][j]);",
		  "            else dp[i][j] = dp[i-1][j];",
		  "            dp[i][j]=min(INF, dp[i][j]);",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "Coin change min 1 bounded"
	  },
	  "Disjoint Set Union": {
		"prefix": "union",
		"body": [
		  "ll parent[200005], sz[200005];",
		  "void make(ll v) {",
		  "    parent[v] = v;",
		  "    sz[v] = 1;",
		  "}",
		  "ll find(ll v) {",
		  "    if(parent[v]==v) return v;",
		  "    return parent[v] = find(parent[v]);",
		  "}",
		  "void union_set(ll a, ll b) {",
		  "    a = find(a);",
		  "    b = find(b);",
		  "    if(a!=b) { //they do not belong to the same parent/set",
		  "        if(sz[a] < sz[b]) swap(a,b);",
		  "        parent[b] = a;",
		  "        sz[a] += sz[b];",
		  "    }",
		  "}",
		  "ll count_sets(vector<ll> &v) {",
		  "    ll ans = 0;",
		  "    for(auto x:v) {",
		  "        if(x==find(x)) ans++;",
		  "    }",
		  "    return ans;",
		  "}"
		],
		"description": "Disjoint Set Union"
	  }
	  
}