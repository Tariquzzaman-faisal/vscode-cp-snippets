{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"FileIO": {
		"prefix": "fio",
		"body": [
			"#ifndef ONLINE_JUDGE",
			"freopen(\"in.txt\", \"r\", stdin);",
    		"freopen(\"out.txt\", \"w\", stdout);",
			"#endif"
		],
		"description": "File io from in.txt and out.txt"
	},
	"CP": {
		"prefix": "cp",
		"body": [
			"#include <bits/stdc++.h>",
			"#define ll long long",
			"#define ff first",
			"#define ss second",
			"#define pll pair<ll,ll>",
			"#define pb push_back",
			"#define YES cout<<\"YES\\n\"",
			"#define NO cout<<\"NO\\n\"",
			"#define dbg(x) cout<<\"x=\"<<x<<\"\\n\";",
			"#define MOD 1000000007",
			"#include<ext/pb_ds/assoc_container.hpp>",
			"#include<ext/pb_ds/tree_policy.hpp>",
			"#define linecase() cout<<\"-----------------------\\n-----------------------\\n\";",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"ll pwr(ll a, ll b) {a %= MOD; ll res = 1; while (b > 0) {if (b & 1) res = res * a % MOD; a = a * a % MOD; b >>= 1;} return res;}",
			"template <typename T> using o_set = tree<T, null_type, greater_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"const ll INF = 0x3f3f3f3f3f3f3f3f;",
			"//Did you take input properly?",
			"",
			"void solve()",
			"{",
			"\t$1",
			"}",
			"",
			"int main()",
			"{",
			"\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);",
			"\t#ifndef ONLINE_JUDGE",
			"\tfreopen(\"in.txt\", \"r\", stdin);",
    		"\tfreopen(\"out.txt\", \"w\", stdout);",
			"\t#endif",
			"\tll t;",
			"\tcin >> t;",
			"\twhile(t--) solve();",
			"\treturn 0;",
			"}"
		],
	},
	"Binary Indexed Tree": {
		"prefix": "BIT",
		"body": [
		  "class BIT {",
		  "private:",
		  "    vector<ll> data;",
		  "    ",
		  "public:",
		  "    BIT(vector<ll> nums) {",
		  "        data.resize(nums.size() + 1);",
		  "        for (ll i = 1; i <= nums.size(); ++ i) {",
		  "            add(i, nums[i]);",
		  "        }",
		  "    }",
		  "    ",
		  "    BIT(ll n) {",
		  "        data.resize(n + 1);",
		  "    }",
		  "    ",
		  "    // add the value val to index i",
		  "    void add(ll i, ll val) {",
		  "        while (i <= data.size()) {",
		  "            data[i] += val;",
		  "            i += (i & (-i));",
		  "        }",
		  "    }",
		  "    ",
		  "    // get the prefix sum from 0 to i",
		  "    ll sum(ll i) {",
		  "        ll v = 0;",
		  "        while (i) {",
		  "            v += data[i];",
		  "            i -= (i & (-i));",
		  "        }",
		  "        return v;",
		  "    }",
		  " ",
		  "    // get the range sum between [i, j]",
		  "    ll queryRange(ll i, ll j) {",
		  "        ll s = sum(j);",
		  "        if(i>0) s -= sum(i-1);",
		  "        return s;",
		  "    }",
		  "};",
		  ""
		],
		"description": "Binary Indexed Tree"
	  },
	  "Inversion Count": {
		"prefix": "invcnt",
		"body": [
		  "ll a[800080], ans=0;",
		  "void Merge(ll ls, ll le, ll hb, ll he)",
		  "{",
		  "\tll k = 0, x = ls;",
		  "\tll temp[he - ls + 3];",
		  "\twhile (ls <= le && hb <= he)",
		  "\t{",
		  "\t\tif (a[ls] <= a[hb]) temp[k++] = a[ls++];",
		  "\t\telse ans +=(le-ls+1), temp[k++]=a[hb++];",
		  "\t}",
		  "\twhile (ls <= le) temp[k++] = a[ls++];",
		  "\twhile (hb <= he) temp[k++] = a[hb++];",
		  "\tfor (ll i = x; i <= he; i++) a[i] = temp[i-x];",
		  "\treturn;",
		  "}",
		  "",
		  "void MergeSort(ll lo, ll hi)",
		  "{",
		  "\tll mid = (lo + hi) >> 1;",
		  "\tif (lo < hi)",
		  "\t{",
		  "\t\tMergeSort(lo, mid);",
		  "\t\tMergeSort(mid + 1, hi);",
		  "\t\tMerge(lo, mid, mid + 1, hi);",
		  "\t}",
		  "}"
		],
		"description": "Inversion Count"
	  },
	  "Nested for loop": {
		"prefix": "for2",
		"body": [
		  "for (ll i = 0; i < ${1:n}; i++)",
		  "{",
		  "    for (ll j = 0; j < ${2:m}; j++)",
		  "    {",
		  "        ",
		  "    }",
		  "}",
		  ""
		],
		"description": "Nested for loop"
	  },
	  "for auto": {
		"prefix": "fora",
		"body": [
		  "for(auto ${1:x}:${2:y}) {",
		  "   $3",
		  "}"
		],
		"description": "for auto"
	  },
	  "for 1 to n": {
		"prefix": "for1",
		"body": [
		  "for(int ${1:i}=1;i<${2:n};$1++) {",
		  "    $3",
		  "}"
		],
		"description": "for 1 to n"
	  },
	  "for 0 to n": {
		"prefix": "for0",
		"body": [
		  "for(int ${1:i}=0;i<${2:n};$1++) {",
		  "    $3",
		  "}"
		],
		"description": "for 0 to n"
	  }
}